% ---------------------------------------------------------------------------
%        Documento híbrido LaTeX - R (Sweave) 
%  
%  Stangle("cursoR.Rnw",output="cursoR-code.R") Extraer código R
%  No olvidar incluir => [width=0.6\textwidth]
% ---------------------------------------------------------------------------

% Header ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\documentclass[twoside,11pt]{article}
\usepackage[spanish]{babel} 

\usepackage[utf8]{inputenc} %% permite teclear directamente acentos (en Linux [latin1]; Win [ansinew])
\usepackage[T1]{fontenc}       %% font encoding, permite separación correcta de palabras con acentos
\usepackage{lmodern}           %% fonts vectoriales Typo 1
\usepackage{textcomp}          %% text companion fonts

\usepackage{xspace}            %% `Smart space' helps to avoid the mistake of missing spaces after command names
\usepackage{setspace}          %% interlineado, mas abajo selecciona espacio sencillo, doble o 1.5 
\usepackage{color}             %% para usar colores
\usepackage[pdftex]{graphicx} 
      \graphicspath{{./}{Figuras/}}
\usepackage{subfig} 
%\usepackage{makeidx}
%  \makeindex      %ejecutar: 'makeindex cursoR' en una ventana de DOS
\usepackage[letterpaper]{geometry} %% define tamaño del papel y modif margenes... pendiente, por lo pronto ver sig. lineas
% Dimensiones del texto y margenes
\setlength{\oddsidemargin}{0cm}
\setlength{\evensidemargin}{1.6cm}
\setlength{\textwidth}{14.9cm}
\addtolength{\textheight}{1cm}
\addtolength{\voffset}{0cm}
\addtolength{\topmargin}{0cm}
\addtolength\headheight{2.5pt}

\usepackage[backref=page,colorlinks=true]{hyperref}  

\hypersetup{colorlinks,
            citecolor=blue,
            filecolor=black,
            linkcolor=blue,
            urlcolor=blue}

\usepackage[definethebibliography]{easybib}
\newcommand{\R}{\textsf{R}}
\SweaveOpts{eps=FALSE}

%*****************************************************************************
% Fin del preambulo, inicio del documento            
%*****************************************************************************

\title{Introducción a \R{}}
\author{Héctor Villalobos}

\begin{document}
\SweaveOpts{concordance=FALSE}
\maketitle

\vskip 1cm

\begin{flushright}
\textit{Departamento de Pesquerías y Biología Marina\\
Centro Interdisciplinario de Ciencias Marinas\\
Instituto Politécnico Nacional}
\end{flushright}

\vskip 1cm

\onehalfspacing

Este curso introductorio    tiene por objeto mostrar el uso básico de \R{} desde un enfoque práctico. Los temas planteados en esta guía serán cubiertos durante cuatro sesiones diarias de 5 horas (20 horas en total). Se sugiere la lectura de este documento al mismo tiempo que se prueban los comandos en la computadora, de tal manera que el usuario se vaya familiarizando progresivamente con el programa y sus comandos más sencillos. Los comandos y funciones que no se explican en esta guía serán comentados durante el curso. A lo largo de este documento, los comandos y sus resultados se muestran en un tipo de letra diferente al resto del texto para facilitar su seguimiento y comparación. 
  
De acuerdo con esta lógica, primero se indica dónde obtener el programa y cómo instalarlo. A continuación se ejemplifican las estructuras de datos u  objetos más usuales en \R{}. Después se procede a manipular dichos objetos realizando algunas operaciones y creando gráficos sencillos. Esta primera etapa de familiarización con el entorno de \R{} termina presentando el sistema de ayuda en línea del programa y algunos \textit{demos} de funciones gráficas avanzadas.

En una etapa posterior se introduce el uso de ``\textit{scripts}'' y de los editores de texto que interactuan con \R{}, facilitando su uso y permitiendo la repetitibilidad de nuestros análisis. Asimismo se ilustra la importación de datos externos y su manipulación para obtener estadísticas descriptivas y diferentes formas de representación gráfica. Se ejemplifica también la exportación de resultados y de gráficas para su uso posterior. A título de ejemplo, se presentan algunos de los análisis estadísticos de uso común, como la regresión lineal, la estimación no lineal y el análisis de varianza.

\vskip 1cm
\begin{flushleft}
\line(1,0){150}\\
Este documento fue creado usando \textbf{Sweave} = \R{} + \LaTeX{} \\
\end{flushleft}

\newpage

  \tableofcontents

\newpage

% +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


\section{¿Qué es \R{}?}%\addcontentsline{toc}{section}{Introdución}

   \R{} es un poderoso y flexible ambiente de programación para el análisis de datos y  la elaboración de gráficas con calidad de publicación. Existen versiones compatibles con \textit{Windows}, \textit{Mac OS X} y \textit{Linux}. \R{} es ``\textit{free software}''\footnote{La definición moderna tiene cuatro puntos, numerados del 0 al 3. El \textit{software} se considera ``libre'' si garantiza al usuario las siguientes libertades:
\begin{enumerate}
	\item[0.] Libertad de usar el programa, con cualquier propósito.
	\item	Libertad de estudiar cómo funciona el programa y modificarlo, adaptándolo a las propias necesidades.
	\item Libertad de distribuir copias del programa, con lo cual se puede ayudar a otros usuarios.
	\item Libertad de mejorar el programa y hacer públicas las mejoras a los demás, de modo que toda la comunidad se beneficie.
\end{enumerate}
Las libertades 1 y 3 requieren que el código fuente este disponible (\url{https://es.wikipedia.org/wiki/Software_libre}).}, lo que significa no solo que es gratuito, sino que además tenemos la libertad de usarlo para cualquier propósito, estudiar su funcionamiento, adaptarlo a nuestras necesidades, mejorarlo y compartirlo con otros usuarios. 

\R{} es considerado como un dialecto de \textit{S}, lenguaje desarrollado en los laboratorios Bell (compañia de investigación y desarrollo científico perteneciente actualmente a Nokia) y que estuvo disponible comercialmente en el \textit{software S-PLUS}\textregistered{}.  

La distribución básica de \R{} contiene funciones para un gran número de procedimientos estadísticos, incluyendo: modelos lineales, GLM, modelos de regresión no lineales, series de tiempo, pruebas paramétricas y no paramétricas, etc.  Posee también un ambiente gráfico flexible con numerosas funciones que permite la creación de diversos tipos de representación de los datos. Existen también paquetes adicionales (``\textit{add-on packages}'') escritos por otros usuarios que permiten extender las capacidades de \R{}. En la sección \ref{sec:addon} se muestra la instalación de paquetes adicionales. 


\section{Obtener e Instalar \R{}}

La versión más reciente de \R{} es la \Sexpr{substr(version$version.string, 11, 30)} y puede obtenerse del sitio web oficial: ``\textit{The \R{} Project for Statistical Computing}'' (\url{http://www.r-project.org/}), el cual contiene las ligas hacia diferentes servidores ``espejo'' distribuidos en todo el mundo.  En estos servidores se puede descargar el codigo fuente de \R{} o una versión precompilada para la plataforma de nuestro interés (\textit{Linux, Mac OS X, Windows}).  

En este documento comentaremos la instalación y el uso de \R{} bajo \textit{Windows 10}, sin embargo, salvo algunas diferencias en la instalación debidas a la gestión de permisos, el resto de las instrucciones de esta guía son válidas para los otros ``sabores'' de \textit{Windows} (\textit{7, Vista, XP}). En el caso de \textit{Linux} y \textit{Mac OS X} algunas funciones pueden diferir.

Una vez descargado el archivo \textbf{\Sexpr{paste("R", substr(version$version.string, 11, 15), "win.exe", sep="-")}}, la instalación es muy simple, basta ejecutarlo para instalar \R{}. En el caso de \textit{Windows Vista} y \textit{Windows 7} se requieren privilegios de administrador para poder efectuar la instalación. Durante la instalación se irán desplegando una serie de ventanas, en la mayoría de las cuales seleccionaremos las opciones por defecto: 

\begin{itemize}
	\item \textit{Select setup language}: Se recomienda seleccionar ``English''. La razón de esto es que aunque el menú de \R{} y algunos mensajes están traducidos en varios idiomas --entre ellos el español-- el sistema de ayuda y muchos recursos en Internet solo están disponibles en inglés, por lo que una busqueda en este idioma producirá más resultados que en español o cualquier otro idioma. 
	
	\item \textit{Welcome screen}: ``Next'' para continuar

	\item \textit{License}: ``Next'' para continuar

	\item \textit{Select Destination Location}: Se recomienda instalar en el directorio por defecto, el cual normalmente es: ``C:$\backslash$Archivos de Programa$\backslash$R$\backslash$R-X.YY.Z'' (``C:$\backslash$Program Files$\backslash$R$\backslash$R-X.YY.Z'', si el sistema operativo está en inglés), donde R-X.YY.Z se refiere a la versión que se está instalando, en este caso \Sexpr{paste("R", substr(version$version.string, 11, 15), sep="-")}. 
	
\begin{figure}[!h]
 \centering
  \includegraphics[width=0.6\textwidth]{./Screenshoots/installR01}
%  \caption{Ruta de instalación de \R{}}
  \label{fig:Instal03}
\end{figure}

	\item \textit{Select Components}: ``Next'' para continuar.
	
	En computadoras con una arquitectura y sistema operativo de 64 bits la opción por defecto es instalar dos versiones de \R{}, una de 32 bits y otra de 64 bits, generando dos iconos en el escritorio. En computadoras de 32 bits únicamente se instalará y generará el icono de la version correspondiente. Mayores detalles sobre  cual version utilizar se pueden ver en \url{https://cran.r-project.org/bin/windows/base/rw-FAQ.html#Should-I-run-32_002dbit-or-64_002dbit-R_003f}. 

	\item \textit{Startup options}: Seleccionar ``No (accept defaults)''. Si se elige ``Yes (customized startup)'' el programa de instalación pregunta si se desea utilizar el programa en modo MDI (ver Figura \ref{fig:MDI}) o SDI (ver Figura \ref{fig:SDI}); si se prefiere la ayuda en modo de texto o html y el tipo de acceso a Internet (estandar o Internet2).
	
	\item \textit{Select Start Menu Folder}: ``Next'' para continuar
	\item \textit{Select Additional Tasks}: ``Next'' para continuar

\end{itemize}





\section{Iniciar y terminar una sesión en \R{}}

Una vez instalado, iniciamos \R{} haciendo doble click sobre el icono correspondiente. Si se desea ejecutar la versión instalada en la memoria USB proporcionada, es necesario seleccionar el archivo ejecutable: \textbf{Rgui.exe} que se encuentra en el directorio ``Z:$\backslash$Archivos de Programa$\backslash$R$\backslash$R-X.YY.Z$\backslash$bin$\backslash$i386'', donde ``Z'' es la letra asignada por \textit{Windows} a la memoria USB\footnote{Si la memoria se conecta siempre en el mismo puerto es muy probable que \textit{Windows} le asigne la misma letra, de tal manera que es posible crear un atajo a  \textbf{Rgui.exe} en la raiz de la memoria}.

Como puede verse, la apariencia de \R{} es bastante simple: La barra de menú es muy sencilla, puesto que no incluye prácticamente ninguna de las opciones que acostumbramos ver en otros programas de estadística y dependiendo del modo en que se inició (MDI o SDI) puede tener o no una barra de herramientas igualmente sencilla. En el modo MDI (\textit{multiple document interface}) las ventanas adicionales (p. ej. gráficas) residen bajo la ventana principal de \R{} (Figura \ref{fig:MDI}), mientras que en el modo SDI (\textit{single document interface}) todas las ventanas son independientes (Figura \ref{fig:SDI}). El modo MDI es la opción por defecto, sin embargo cuando se utiliza \R{} en conjunto con algunos editores de texto es necesario utilizar el modo SDI.


\begin{figure}[!h]
 \centering
  \includegraphics[width=0.85\textwidth]{./Screenshoots/InstallR_MDI}
  \caption{Modo MDI (multiple document interface)}
  \label{fig:MDI}
\end{figure}

\begin{figure}[!h]
 \centering
  \includegraphics[width=0.85\textwidth]{./Screenshoots/InstallR_SDI}
  \caption{Modo SDI (single document interface)}
  \label{fig:SDI}
\end{figure}


Si el lenguaje mostrado en el programa no es el deseado, es posible cambiarlo por medio del Menu \textbf{Edit/GUI Preferences\ldots{}} añadiendo ``en'' en la caja correspondiente a la opción: \textit{Language for menus and messages}. Otra opción es editar el archivo de configuración \textbf{Rconsole} que se encuentra en el directorio de instalación ``C:$\backslash$Archivos de Programa$\backslash$R$\backslash$R-X.YY.Z$\backslash$etc$\backslash$''. Abrir este archivo con un editor de textos y buscar casi al final las líneas:

\begin{flushleft} 
 \Verb@##@ Language for messages \\
  language = 

  \vskip 0.2cm

y añadir simplemente ``en'' después del signo de igual (otras opciones son: ``es'' para español y ``fr'' para francés).
\end{flushleft}

En lo que denominaremos consola, el símbolo ``\Verb@>@'' se conoce como \textit{prompt}, el cual nos indica que \R{} está listo para recibir comandos. Cuando la sintaxis de una instrucción no está completa, por ejemplo si falta cerrar un paréntesis,  la consola muestra el \textit{prompt} de continuación ``\Verb@+@''.  Ambos símbolos aparecen automáticamente en la consola de \R{}, por lo que al seguir los ejemplos de esta guía \textbf{no deben ser tecleados por el usuario}.


 \section{Usando ``scripts''}

Cuando deseamos repetir un procedimiento, verificar nuestros resultados o modificar nuestro análisis, es muy útil guardar los comandos utilizados. Así creamos lo que se conoce como ``script'' que es simplemente un archivo ascii que contiene los pasos que seguimos en nuestro análisis. La extensión recomendada para este tipo de archivo es *.R y puede ser visualizado con cualquier procesador de palabras (Notepad, Wordpad, etc.).

En \R{}, bajo el menú \textbf{File/New Script}, al seleccionar esta opción se abre una ventana en la que podemos escribir nuestros comandos. 

En el script, podemos incluir comentarios usando el símbolo de número ``\#''. Este símbolo indica a \R{} que no debe ejecutar lo que le sigue hasta la próxima línea. Para separar comandos escritos en la misma línea utilizamos el punto y coma ``;'' entre los comandos. 


 \section{RStudio como editor de scripts} 

Una manera de facilitar la creación y manipulación de scripts en \R{} es por medio de un editor que resalte la sintaxis con diferentes colores, y al mismo tiempo que pueda interactuar con \R{} enviando código a la consola para su ejecución. 

Existen diferentes opciones como EMACS, JGR, R Commander, Sciviews y Tinn-\R{}. La página web: \url{http://www.sciviews.org/\_rgui/} contiene ligas para estos y otros editores. Sin embargo dada la facilidad de instalación, de uso y sus caracteristicas, se recomienda el uso de RStudio  el cual puede descargarse desde la siguiente página: \url{http://www.rstudio.org}. RStudio es lo que se conoce como un Ambiente de Desarrollo Integrado (IDE, por sus siglas en inglés) que bajo una misma ventana agrupa el editor de scripts, la consola de \R{}, el \textit{workspace} con los objetos creados, el histórico de los comandos utilizados, la ayuda, las gráficas, paquetes instalados y archivos en el directorio de trabajo.

\subsection*{Instalación de RStudio}
En este curso instalaremos la version 0.99.893 de RStudio, para lo cual ejecutamos el archivo RStudio-0.99.893.exe y, al igual que en el caso de  \R{} seguiremos las instrucciones del instalador.  

\begin{itemize}
	\item \textit{Welcome to the RStudio Setup Wizard}: Pantalla de bienvenida del instalador, seleccionar ``Next'' para continuar
	\item \textit{Choose Install Location}: Seleccionar carpeta de instalación, puede aceptarse la propuesta por el programa o elegir otra. ``Next'' para continuar
	\item \textit{Choose Start Menu Folder}: Carpeta para crear atajo para ejecutar el programa, la opción por defecto está bien. Pulsar ``Install'' para iniciar la instalación. 
	\item \textit{Completing the RStudio Setup Wizard}: Seleccionar ``Finish''
\end{itemize}

Una vez instalado basta pulsar el icono de RStudio para comenzar a utilizarlo en conjunto con R.

\begin{figure}[!h]
 \centering
  \includegraphics[width=\textwidth]{./Screenshoots/RStudio}
%  \caption{}
  \label{fig:RStudio}
\end{figure}

\subsection*{Configuración y uso de RStudio}
Normalmente no se requieren pasos adicionales para configurar RStudio. Sin embargo se recomienda explorar el menú de RStudio \textbf{Tools/Options}, donde se pueden modificar algunas opciones de estilo.

Los comandos se escribirán en el área de scripts, en la parte superior izquierda, y para enviarlos a que sean evaluados en la consola se deben pulsar las teclas Ctrl+Enter o bien seleccionar el botón Run en la parte superior derecha de la venatana de scripts.

A partir de este punto, toda la interacción con \R{} se hará a través de RStudio.

\section{Usando \R{} como una super calculadora}

<<eval=TRUE, echo=FALSE>>=
options(width=70)
@

Con \R{} podemos realizar cualquier operación aritmética usando los operadores habituales:
<<>>=
 3+6
 8*9
 10-8
 5/2
 4^2
@

Otras funciones también disponibles incluyen logaritmos, raíz cuadrada, seno, coseno, etc. En estos casos, los nombres de los comandos son muy intuitivos:
<<>>=
 log(100)
 log10(100)
 exp(2)
 sqrt(16)
 sin(90)
 cos(90)
@

Al realizar varias operaciones juntas aplican las reglas de precedencia usuales (la división y la multiplicación se ejecutan antes que la suma y la resta), mismas que pueden alterarse usando paréntesis:
<<>>=
 3+2*5
 (3+2)*5
@


Para terminar la sesión de trabajo, podemos simplemente cerrar la ventana de igual forma que con cualquier otro programa de \textit{Windows}, o bien mediante el comando:

<<eval=FALSE>>=
 q()
@

En ambos casos \R{} pregunta si deseamos guardar una ``imagen'' del espacio de trabajo (``\textit{work\-space image}''). Esta incluye el historial de comandos utilizados (archivo '.Rhistory') y los objetos creados durante la sesión (archivo '.RData').  Si decidimos guardar dicha imagen, los comandos y los objetos serán restaurados al iniciar la siguiente sesión de \R{}. 

Sin embargo, para evitar posibles confusiones con datos de sesiones previas, es conveniente guardar los objetos creados desde el menú \textbf{File/Save Workspace\ldots}, y si así lo deseamos el historial de comandos mediante \textbf{File/Save History\ldots}, lo que nos permite asignarle un nombre y así distinguirlo de otros análisis. Podemos restaurar los objetos o comandos guardados a través del menú  (\textbf{File/Load Workspace\ldots}, \textbf{File/Load History\ldots} o bien haciendo doble click sobre el archivo ('*.RData', '*.Rhistory') correspondiente.   



\section{Objetos en \R{}}

\R{} opera a través de estructuras de datos que tienen nombre. Pueden ser de diferentes tipos, dependiendo de su estructura y de los datos que contengan, así podemos distinguir entre vectores, matrices, \textit{data frames} y listas principalmente\footnote{Las funciones también son objetos, pero por el momento nos interesan solamente aquellos objetos que contienen o pueden contener nuestros datos.}. Conocer el tipo de objeto es importante porque determina en gran medida las operaciones que podemos efectuar con ellos. 

Para ilustrar las diferentes estructuras de datos utilizaremos el operador de asignación (\textit{assignment}): \Verb@"<-"@, el cual permite asignar un valor o una colección ordenada de valores a un objeto determinado.

%\newpage
Por ejemplo, la instrucción

<<>>=
 b <- 5
@
asigna el valor 5 al objeto denominado  \Verb@b@. Aunque no se acostumbra, el operador de asignación se puede escribir en el otro sentido:

\begin{Schunk}
\begin{Sinput}
> b -> 5
\end{Sinput}
\end{Schunk}

En ambos casos se crea un escalar (o vector de longitud uno) que estará disponible para operaciones subsecuentes:

<<>>=
 10*b
 sqrt(b)
@

  \subsection*{Vectores}

Los vectores son el tipo de estructura más simple en \R{}. Asignemos por ejemplo una serie de números del 1 al 6 a un objeto que llamaremos \Verb@w@. Para ello utilizamos la instrucción: 

<<>>=
 w <- 1:6
@

Para verificar el contenido de \Verb@w@ simplemente escribimos su nombre:

<<>>=
 w
@

Como se puede inferir del ejemplo anterior, ``:'' sirve para crear una secuencia de números de uno en uno. Si deseamos crear secuencias\index{secuencias} con intervalos diferentes,  por ejemplo cada 0.5 unidades, podemos usar la función \Verb@seq()@:

<<>>=
 seq(1, 6, 0.5)
@

En este ejemplo indicamos el inicio (1) y el final (6) de la secuencia, así como el incremento (0.5). Al inicio de la secuencia anterior aparece ``\Verb@[1]@'', lo que nos indica que \R{} desplegó el resultado a partir del primer valor del vector. Si en un renglón hubiera espacio para únicamente 20 números, una secuencia que ocupara dos renglones comenzaría en ``\Verb@[1]@'' en el primero y en ``\Verb@[21]@'' en el segundo renglón.

Regresando a nuestro ejemplo, \Verb@w@ es un vector numérico, pero también podemos tener vectores de caracteres:

<<>>=
 x <- c("a", "a", "a", "b", "b", "b")
 x
@

En este ejemplo, usamos la instrucción \textit{combine}  \Verb@c()@ para combinar las letras en un solo objeto.  De manera similar, el vector de nuestro primer ejemplo puede crearse también usando la instrucción:  \Verb@w <- c(1, 2, 3, 4, 5, 6)@. En el caso de la creación del vector \Verb@x@ usamos comillas para indicar que se trata de texto y no de objetos ya existentes.  Imaginemos que en algún momento de la sesión se hicieron las asignaciones  \Verb@a <- 2.5@ y \Verb@b <- 3.6@ y después lo olvidamos. Si en un momento posterior de la misma sesión deseáramos crear el vector de caracteres del ejemplo anterior pero olvidásemos usar las comillas, el resultado sería totalmente diferente:

<<echo=FALSE>>=
 a <- 2.5
 b <- 3.6
@ 

<<>>=
 xx <- c(a, a, a, b, b, b)
 xx
@

Además de los vectores numéricos y de caracteres que acabamos de ejemplificar, también hay vectores lógicos que resultan de la evaluación de expresiones:

<<>>=
 ww <- w > 4
 ww
@

Este último tipo de vector es muy útil para indexar otros vectores, pues nos permite, por ejemplo, extraer elementos específicos que cumplen con cierta condición (en este caso, aquellos que son mayores que 4):

<<>>=
 w[ww]
@

Más ejemplos sobre esto se muestran después de presentar los demás objetos de \R{}.

\subsection*{Matrices}
El siguiente tipo de objeto que nos interesa es la matriz:

<<>>=
 y <- matrix(1:20, ncol = 4)
 y
@ 

Nótese cómo hemos indicado el número de columnas que queríamos con el argumento \Verb@ncol@. También podemos precisar cómo queremos que los datos sean ordenados en la matriz al incluir el argumento \Verb@byrow@, que instruye a la función \Verb@matrix()@ a llenar primero los renglones:

<<>>=
 matrix(1:20, byrow = TRUE, ncol = 4)
@

Incluso podemos asignar nombres a las columnas y renglones de la matriz, para lo cual añadimos el argumento \Verb@dimnames@:


<<keep.source=TRUE>>=
 y <- matrix(1:20, byrow = TRUE, ncol = 4, dimnames = list(paste("r", 
             1:5, sep = ""), paste("c", 1:4, sep = ".")))
 y
@

El valor de \Verb@dimnames@ en la función anterior utiliza otras funciones (\Verb@list()@ y \Verb@paste()@) con sus respectivos argumentos. Para comprender su propósito podemos evaluarlas de manera independiente.

\subsection*{\textit{Data frames}}
Una característica que comparten los vectores y las matrices es que pueden contener un solo tipo de valores (numéricos, caracteres o lógicos). En muchas ocasiones, nuestros datos contienen una mezcla de variables numéricas y factoriales. Esta información puede manejarse por medio de un \textit{data frame}, muy similar a la matriz pero que puede contener más de un tipo de datos: 

<<>>=
 z <- data.frame(x, w)
 z
@

\subsection*{Listas}
Una lista pude combinar cualquier tipo de objetos, incluyendo otras listas.

<<>>=
 Z <- list(V.w=2*w, V.x=x, M.y=log(y))
 Z
@

Es importante mencionar que \R{} es sensible al uso de mayúsculas/minúsculas, de tal forma que nuestros objetos \Verb@z@ y \Verb@Z@ son diferentes.


\subsection*{Indexar objetos}

Podemos tener acceso a elementos particulares de un objeto usando índices. Por ejemplo, si nos interesan los primeros tres elementos del vector \Verb@x@:

<<>>=
 x[1:3]
@  

En el caso de matrices y \textit{data frames} debemos indicar también la columna, por ejemplo, para extraer de la matriz \Verb@y@ los elementos correspondientes a los renglones 4--5 y a las columnas 3--4 escribimos:

<<>>=
 y[4:5, 3:4]
@
o tal vez nos interesa la columna 2 completa:

<<>>=
 y[, 2] 
@
en el caso de un \textit{data frame} además podemos acceder a las columnas mediante el nombre del \textit{data frame} seguido del símbolo ``\$'' y del nombre de la columna:

<<>>=
 z$x
 z$w
@ 
por último, en el caso de las listas procedemos de manera similar:

<<>>=
 Z$M.y
@ 
para extraer solo los renglones tercero y cuarto de la segunda columna de la matriz anterior:
 
<<>>=
 Z$M.y[3:4, 2]
@ 
o de manera alternativa:

<<>>=
 Z[[3]][3:4, 2]
@ 
 
 \subsection*{Atributos de los objetos}

Una vez que los objetos han sido creados podemos saber a que clase pertenecen inspecionándolos o de manera más precisa usando la función \Verb@class()@. Veamos lo reportado por esta funcion para los objetos creados hasta este momento:

<<>>=
 class(w); class(x); class(ww); class(y); class(z); class(Z)
@

Los objetos en \R{} tienen atributos, por ejemplo el modo en que están almacenados (\Verb@mode()@, \textit{``numeric'', ``character'', ``logical''}, \ldots{}) y su longitud (\Verb@length()@), que corresponde al número total de elementos de un vector o matriz, mientras que en el caso de un data frame es el número de columnas, y en una lista el número de elementos de esta.

Otros atributos de un objeto corresponden a sus dimensiones y nombres de las columnas y  renglones (o de los elementos de la lista). La función \Verb@attributes()@ puede ser útil para conocer algunos de estos atributos, aunque \Verb@str()@ nos proporciona mayores detalles sobre la estructura del objeto.

<<>>=
 attributes(w); str(w)
 attributes(Z); str(Z)
@



\section{Operaciones simples}


Ahora utilicemos algunos de los objetos creados previamente para ilustrar algunas operaciones sencillas. Por ejemplo, si queremos calcular la raíz cuadrada de los elementos del vector \Verb@w@ usamos la función \Verb@sqrt()@:

<<>>=
 sqrt(w)
@

La sintaxis en el caso de una matriz es idéntica:
<<>>=
 sqrt(y)
@ 

La diferencia con una hoja de cálculo, donde la fórmula se tiene que aplicar a cada elemento --ya sea escribiéndola o copiándola--, es evidente.

También podemos aplicar una operación de este tipo a una sola columna de una matriz o de un data frame:

<<>>=
 sqrt(z$w)
@

En este caso especificamos que nos interesa la columna \Verb@w@ del data frame \Verb@z@. Alternativamente, podemos emplear la notación: \Verb@sqrt(z[ , 2])@. 


Para las operaciones con vectores y matrices, es importante la notación  empleada para obtener el resultado deseado:

<<>>= 
 A <- matrix(c(1,2,3,4), ncol=2)
 b <- c(2,3)
@

La operación \Verb@A * b@ ejecuta la multiplicación elemento por elemento, y es equivalente a \Verb@b * A@:

\begin{Schunk}
\begin{Soutput}
         A      *  b
     [,1] [,2]    [1]               [,1] [,2]
[1,]    1    3      2    =     [1,]  1*2  3*2
[2,]    2    4      3          [2,]  2*3  4*3      
\end{Soutput}
\end{Schunk}

<<>>= 
 A * b
@
 En cambio, el producto matricial 
 
\begin{Schunk}
\begin{Soutput}
         A     %*% b
     [,1] [,2]    [1]                     [,1] 
[1,]    1    3      2    =     [1,]  1*2 + 3*3
[2,]    2    4      3          [2,]  2*2 + 4*3      
\end{Soutput}
\end{Schunk}
 
se obtiene mediante: 
<<>>= 
 A %*% b 
@

La transposición de una matriz se obtiene mediante:
<<>>=
 t(A)
@

Y la inversa
<<>>=
 solve(A)
@

%\newpage
 
\section{Gráficas simples}

Para mostrar la creación de gráficos sencillos vamos a crear un ``data frame''   con dos columnas, la primera que denominaremos ``grupo'', y la segunda ``var1''. Este ejemplo ilustra también el uso de la función \Verb@rnorm()@, que produce números aleatorios distribuidos normalmente.

<<echo=FALSE>>=
set.seed(1)
@

<<>>=  
 z <- data.frame("grupo" = sort(rep(c("a", "b"), 8)), "var1" = rnorm(16))
 z
@  

La función \Verb@plot()@ produce una gráfica de dispersión:

\begin{center}
<<fig=TRUE, echo=TRUE>>= 
 plot(z$var1)
@
\end{center}

Si queremos un histograma usamos la función \Verb@hist()@:

\begin{center}
<<fig=TRUE, echo=TRUE>>= 
 hist(z$var1)
@
\end{center}

Ahora intentemos hacer una gráfica de cajas y bigotes de \Verb@var1@ con respecto al \Verb@grupo@, añadiendo título y etiquetas a los ejes \Verb@x@ y \Verb@y@:

\begin{center}
<<fig=TRUE, echo=TRUE, keep.source=TRUE>>= 
 boxplot(var1 ~ grupo, data=z, main="boxplot de prueba", xlab = "grupo",
         ylab = "variable 1")
@
\end{center}


Para explorar otras opciones gráficas, añadiremos una segunda columna a \Verb@z@, y después ordenaremos el data frame con respecto a \Verb@var1@.  A continuación vamos a crear en una sola ventana cuatro gráficas de las mismas variables usando diferentes opciones (solo puntos, solo líneas y ambos): 

<<fig=TRUE, echo=TRUE>>=
 z$var2 <- (z$var1)^2 
 z <- z[order(z$var1), ]
 par(mfrow=c(2,2))
 plot(z$var1, z$var2, type="p", main="solo puntos")
 plot(z$var1, z$var2, type="l", main="solo líneas")
 plot(z$var1, z$var2, type="b", main="puntos y líneas")
 plot(z$var1, z$var2, type="o", main="puntos y líneas\n sobrepuestos")
@

<<echo=FALSE>>=
 graphics.off()
@

Se recomienda familiarizarse con la función \Verb@par()@, que explica los parámetros gráficos que pueden ser modificados por el usuario, por ejemplo el tamaño de la fuente, símbolos, colores, etc.

\section{Enlistar y borrar objetos}

Para saber que objetos tenemos disponibles, podemos enlistarlos usando los comandos: 

<<>>=
 objects()
@

o bien:

<<>>=
 ls()
@

Si ahora queremos eliminar permanentemente algún objeto en particular, digamos la matriz \Verb@y@ usamos:

<<>>=
 rm(y)
 ls()
@

o podemos borrar todos los objetos de una sola vez:

<<>>=
 rm(list=ls())
 ls()
@

Los objetos cuyo nombre comienza por ``.'' están ocultos y no pueden ser mostrados ni borrados como se acaba de explicar. Para ejemplificar esto, creemos un objeto al que llamaremos \Verb@.invisible@:

<<>>=
.invisible <- rnorm(20)
@
ahora ejecutemos los comandos  siguientes:

<<>>=
 ls()
@ 

Como se aprecia, la función \Verb@ls()@ no despliega los objetos ocultos. Para deplegarlos requerimos añadir el argumento \Verb@all = TRUE@ a dicha función:

<<>>=
 ls(all=TRUE)
@
el objeto \Verb@.Random.seed@ fue creado por la función \Verb@rnorm()@ usada previamente. Veamos ahora lo que sucede al intentar borrar a todos los objetos como se hizo anteriormente: 

<<>>=
 rm(list=ls())
 ls(all=TRUE)
@

Como podemos ver, los dos objetos ocultos siguen ahí.  La notación correcta para borrarlos sería la siguiente:

<<>>=
 rm(list=ls(all=TRUE))
 ls(all=TRUE)
@



\section{Buscando ayuda}
Podemos acceder al sistema de ayuda de \R{} mediante ``?'' seguido del nombre de la función que nos interesa o con el comando \Verb@help()@. Probemos esto con algunas de las funciones que hemos utilizado hasta el momento:

\begin{Schunk}
\begin{Sinput}
> ?ls
> help("rnorm")
> help("hist")
> help(par)
> help.search("linear models")
\end{Sinput}
\end{Schunk}

A partir del menú \textbf{Help} también podemos acceder a la ayuda compilada en html, a los di\-fe\-ren\-tes manuales de \R{} en formato pdf que se crearon durante la instalación, a los archivos en línea de la lista de correo de ayuda de \R{}, etc. 

 \section{Instalación de paquetes (``packages'') adicionales}\label{sec:addon}
 
La instalación de \textit{packages} es bastante simple, se puede hacer a partir del menú o de la consola. Los paquetes se encuentran en un servidor de Internet denominado \textit{Comprehensive R Archive Network} (CRAN) y sus espejos distribuidos en diferentes paises. Usualmente, cuando se cuenta con una conexión a Internet adecuada, es preferible instalar desde estos servidores. Es importante señalar que los usuarios de \textit{Windows Vista} y \textit{Windows 7} deben abrir una sesion de \R{} como administrador, lo cual se logra haciendo click con el botón derecho del mouse sobre el icono del programa y después seleccionando ``Ejecutar como administrador'' en el menú desplegado.

Una vez dentro de \R{}, desde el menú seleccionamos la opción: \textbf{Packages/Install package(s)\ldots} Después será necesario elegir un servidor o ``espejo'' y a continuación el \textit{package} de nuestro interés en la lista desplegada.

Desde la consola podemos usar los comandos: \Verb@chooseCRANmirror()@, que nos permite seleccionar el servidor, e \Verb@install.packages()@ indicando el o los \textit{packages} deseados. Pongamos un ejemplo:

<<eval=FALSE>>=
 chooseCRANmirror()
 install.packages("TeachingDemos", dependencies = TRUE)
@

El argumento \Verb@dependencies = TRUE@ instruye a \R{} a descargar e instalar otros paquetes requeridos para el funcionamiento del paquete \Verb@TeachingDemos@. Como puede apreciarse, durante el proceso la consola de \R{} despliega una serie de mensajes, en particular el nombre y tamaño de los archivos descargados, que están en forma de archivos comprimidos (en formato ``*.zip'' para la versión de \textit{Windows}) y que son automáticamente desempacados por \R{}. 

En la memoria USB proporcionada se incluyen algunos de los paquetes disponibles a la fecha en el directorio \Verb@Software/R/contrib_packages@. Estos corresponden a las versiones binarias para \textit{Windows} y se instalan de manera similar al caso anterior. Desde el menú, la opción corresponde a \textbf{Packages/Install package(s) from local zip files\ldots}, mientras que desde la consola la instrucción completa requiere indicar la ruta en donde se ubican los archivos *.zip. La ventaja de usar la consola en lugar del menú radica en que las dependencias también son tomadas en cuenta. Supongamos por ejemplo que ``G'' es la letra asignada por \textit{Windows}  a nuestra memoria, entonces la sintaxis sería:

\begin{Schunk}
\begin{Sinput}
> install.packages("TeachingDemos", repos = NULL, 
+ contriburl = "file:///G:/Software/R/contrib_packages", 
+ dependencies = TRUE)
\end{Sinput}
\end{Schunk}  

Una vez instalado un paquete es necesario cargarlo en la sesión para que esté disponible para usarlo, en el caso de nuestro ejemplo:

%<<>>=
% library(TeachingDemos)
%@

Podemos ahora ver la ayuda de este paquete y ensayar los ejemplos de alguna función, por ejemplo \Verb@my.symbols()@:
\begin{Schunk}
\begin{Sinput}
> ?TeachingDemos
> example(my.symbols)
\end{Sinput}
\end{Schunk}


Cuando ya no necesitamos el \textit{package} podemos desactivarlo usando el comando:
%<<>>=
% detach("package:TeachingDemos")
%@

En el sitio de \R{} se puede consultar la lista de \textit{packages} disponibles con una breve descripción de los mismos. Por lo general, se recomienda buscar el \textit{package} útil para resolver un problema específico, en lugar de intentar instalar y explorar todos los paquetes disponibles.

 
\section{Demos}
Para finalizar esta sección de conceptos generales, se invita al lector a explorar algunas de las capacidades gráficas avanzadas de \R{}, mediante los \textit{demos} incluidos con el programa: 

<<eval=FALSE>>=
 demo('graphics')
@

y:

<<eval=FALSE>>=
 demo('persp')
@
 
% ----------------------------------------------------------------------- 

%Uso avanzado



 \section{Importar datos externos} 
 
En los primeros ejemplos vimos la manera de introducir datos y crear objetos a partir del teclado, pero lo más usual es que tengamos nuestra información en alguna hoja de cálculo o base de datos. 

 \subsection*{Desde el portapapeles}
Cuando la cantidad de datos es pequeña y su fomato sencillo, podemos pasarlos directamente del archivo a la consola de \R{} por medio del portapapeles. Para ello primero copiamos los datos al portapapeles y después escribimos en la consola la instrucción:

<<eval=FALSE>>=
 read.delim("clipboard")
@ 

 \subsection*{Mediante \Verb@read.table()@}
 
Cuando el tamaño de los datos es importante, es preferible usar otro método para leerlos en \R{}. Los archivos de Excel y de Access pueden ser importados mediante funciones especiales, sin embargo lo más sencillo es exportar nuestros datos en formato ascii, puesto que todas las hojas de cálculo y manejadores de bases de datos tienen esta capacidad. Se sugiere salvar los datos en un archivo de texto, con nombres de columnas que empiecen por una letra y sin espacios (si se desean nombres compuestos se puede usar un guión bajo) y usando tabuladores como separadores de columnas (aunque \R{} puede importar datos sin nombres de columnas y separados por espacios, comas, etc.).  

Uno de los comandos de importación de datos externos que más utilizaremos es \Verb@read.table()@ y su sintaxis es la siguiente:

<<eval=FALSE>>=
x <- read.table("ruta/archivo", header, sep)
@

Del lado izquierdo del \textit{assignment}, \Verb@x@ corresponde al objeto que contendrá los datos del archivo importado. Del lado derecho, \Verb@ruta@ se refiere a un directorio, por ejemplo \Verb@"G:/datos"@ y \Verb@archivo@ al nombre --incluyendo la extensión (``.txt'', ``.dat'')-- del archivo externo que contiene los datos. Los argumentos \Verb@header@ y \Verb@sep@ indican si el archivo incluye (\Verb@TRUE@) o no (\Verb@FALSE@) nombres de columnas y el separador de las mismas. Este último puede ser un tabulador (\Verb@"\t"@), un espacio (\Verb@" "@), una coma (\Verb@","@) o punto y coma (\Verb@";"@).

Como primer ejemplo importaremos los datos contenidos en \Verb@archivo_00.txt@, localizado en el directorio \Verb@/Datos/importar@ de la memoria USB. Una rápida inspección de este archivo de texto nos permite ver que se trata de dos columnas numéricas cuyos nombres son \Verb@tmin@ y \Verb@tmax@. Con una observación cuidadosa del archivo además podemos descubrir que las columnas estan separadas por tabuladores y no por espacios.

<<eval=FALSE>>=
a00 <- read.table("G:/Datos/importar/archivo_00.txt", header=TRUE, sep="\t")
@

Una vez los datos importados, estarán disponibles para ser analizados dentro de \R{}. Es importante señalar que el archivo original permanece sin cambios y que los datos solo están disponibles mientras la sesión actual de \R{} se mantenga abierta. Si en una sesión posterior deseamos usar los mismos datos debemos importarlos nuevamente, a menos que hayamos guardado el \textit{workspace} y se haya restaurado en la nueva sesión. 

Una sesión formal de \R{} requiere que definamos nuestro directorio de trabajo (``\textit{working directory}'', \Verb@wd@). Eso simplificará mucho la importación y exportación de datos y figuras, además de que nos ayudará a mantener organizado nuestro trabajo.

Para conocer el directorio de trabajo actual usamos el comando \Verb@getwd()@, mientras que definimos uno diferente mediante \Verb@setwd()@, por ejemplo:

<<eval=FALSE>>=
 setwd('G:/Datos')
@

De esta manera, la sintaxis del ejemplo anterior se puede simplificar:

<<eval=FALSE>>=
a00 <- read.table("./importar/archivo_00.txt", header=TRUE, sep="\t")
@

El ``.'' antes de la diagonal inicial sirve para indicar que \Verb@importar@ es un subdirectorio de \Verb@Datos@.  Como ejercicio, importar los archivos: \Verb@archivo_01.txt@, \Verb@archivo_02.dat@ y \Verb@archivo_03.csv@, sin olvidar inspeccionarlos previamente para ver su estructura.


 \subsection*{Desde archivos de Excel y Access}
 
 Para importar archivos creados con estas aplicaciones, es necesario el uso de paquetes adicionales. Uno de los mas sencillos de instalar  y uilizar es \Verb@RODBC@. La secuencia completa de pasos para importar un archivo de Excel, requiere (1)~cargar el paquete, (2)~establecer una ``conexión'' al archivo, (3)~leer los nombres de las hojas del archivo Excel y (4)~importar la hoja que nos interesa. La sintaxis es la sguiente:
 
<<eval=FALSE>>=
 library(RODBC) 
 con <- odbcConnectExcel("./importar/archivo_04.xls")
 sqlTables(con)
 a04pA <- sqlFetch(con, "A_1962")
@

 En este ejemplo, \Verb@con@ es únicamente la conexión al archivo \Verb@archivo_04.xls@ y es a través de ella que consultamos los nombres de las hojas Excel (\Verb@sqlTables(con)@) e importamos aquella que nos interesa (\Verb@sqlFetch(con, "A_1962")@). Adicionalmente, si ya no se van a importar más datos se cierra la conexión y se quita el paquete de la memoria:

<<eval=FALSE>>= 
 closeAllConnections()
 detach("package:RODBC")
@  

 Otro de los paquetes que permiten leer archivos de Excel  es \Verb@gdata@, que contiene una función llamada \Verb@read.xls()@ que es capaz de leer archivos de la versión 2010 (*.xlsx). Este paquete utiliza scripts escritos en Perl, por lo que además de instalar el paquete en \R{} es necesario instalar una versión de Perl en la computadora.
 
 El procedimiento para importar datos de un archivo Access mediante el paquete \Verb@RODBC@ es equivalente, solamente se requiere sustituir la función que establece la conexión al archivo correspondiente (\Verb@odbcConnectAccess()@).

 Más detalles acerca de la importación de estos y otros tipos de archivos se pueden consultar en el manual \textbf{R Data Import/Export} (R-data.pdf) que se encuentra bajo la carpeta doc/manual de la instalación de \R{}.
 
 
 \subsection*{Un ejemplo práctico} 
 
Vamos ahora a desarrollar un ejemplo más completo de importación y análisis de datos utilizando el archivo \Verb@cibmeteo.txt@:

<<eval=FALSE>>= 
 cibmeteo <- read.table("cibmeteo.txt", header=TRUE, sep="\t")
@

<<echo=FALSE>>=
 cibmeteo <- read.table("cibmeteo.txt", header=TRUE, sep="\t")
@

Estos datos corresponden a lecturas de la temperatura del aire, la humedad relativa, la velocidad y dirección del viento registradas cada media hora de junio de 2006 a mayo de 2007 en la estación meteorológica del CIBNOR en el Comitán, B.C.S. Veamos las dimensiones de este archivo y las variables que contiene:

<<>>=
 dim(cibmeteo)
 names(cibmeteo) 
@

Para tener una primera impresión de los datos, la función \Verb@summary()@ produce una serie de estadísticas descriptivas: 

<<>>=
 summary(cibmeteo)
@

Analicemos la temperatura del aire,  haciendo un primer gráfico de líneas:

\begin{center}
<<fig=TRUE, echo=TRUE>>=
 plot(cibmeteo$temperature, type="l", col = "grey")
@
\end{center}

Dada la frecuencia de las lecturas de temperatura, esta figura resulta poco útil. Procedamos a  resumir la información de alguna manera. Calculemos por ejemplo los extremos (mínimo y máximo) y el promedio diario de la temperatura a partir de las 48 lecturas de cada día. Para ello necesitamos crear un índice que identifique de manera única a cada día, pues en el archivo el año, el mes y el día se encuentran en columnas separadas.

\begin{Schunk}
\begin{Sinput}
> attach(cibmeteo)
> fecha <- paste(year, month, day, sep="-") 
> fecha <- strptime(fecha, "%Y-%m-%d")
> fecha_txt <- as.character(fecha)
> taire <- as.data.frame(
+     cbind(tapply(temperature, list(fecha_txt), min),
+     tapply(temperature, list(fecha_txt), max),
+     tapply(temperature, list(fecha_txt), mean)))
> detach(cibmeteo)
\end{Sinput}
\end{Schunk}

<<echo=FALSE, eval=TRUE>>=
attach(cibmeteo)
fecha <- paste(year, month, day, sep="-")
fecha <- strptime(fecha, "%Y-%m-%d")
fecha_txt <- as.character(fecha)

 taire <- as.data.frame(cbind(
          tapply(temperature, list(fecha_txt), min),
          tapply(temperature, list(fecha_txt), max),
          tapply(temperature, list(fecha_txt), mean)))
@ 

La función \Verb@attach()@ nos permite acceder a las variables contenidas en un \textit{data frame} directamente. En nuestro ejemplo, no fue necesario especificar \Verb@cibmeteo$temperature@ para acceder a la variable \Verb@temperature@ dentro del \textit{data frame} \Verb@cibmeteo@. Otra función muy útil en este ejemplo es \Verb@tapply()@, que nos permite aplicar una función (\Verb@min, max, mean@) a cada celda de una matriz  definida por una combinación única de uno a varios factores (\Verb@fecha_txt@ en nuestro ejemplo).  

Bien, ahora asignemos nombres significativos a las columnas de nuestro nuevo  \textit{data frame}:

<<>>=
 colnames(taire) <- c('tmin', 'tmax', 'tavg')
@

Cuando se usa más de un factor, la función \Verb@tapply()@ genera por defecto una tabla. Supongamos por ejemplo que nos interesa el promedio mensual de temperatura, el código sería el siguiente:

<<>>=
 tapply(temperature, list(month, year), mean)
@

Una manera alternativa de obtener estos valores pero organizados de manera diferente (\textit{e.g.} en un vector) sería usando la función \Verb@aggregate()@:

<<>>=
 aggregate(temperature, by=list(mes=month, año=year), mean)
 detach(cibmeteo)
@

Regresando a los promedios diarios calculados antes, vamos a suavizar los datos con un método que es comunmente utilizado con este propósito: los promedios móviles. Este método consiste en definir una ventana de cierta longitud, por ejemplo 3 (denominado orden=3), y obtener el promedio de los valores primero al tercero, segundo al cuarto, tercero al quinto y por último del valor n-2 al n.

Supongase que tenemos el vector \Verb@Z@ con 8 valores:

<<>>=
 Z <- c(4, 8, 9, 7, 8, 9, 4, 5)
@
y deseamos calcular el promedio móvil de orden 3. Los cálculos a realizar serían:
(4+8+9)/3; (8+9+7)/3; (9+7+8)/3; (7+8+9)/3; (8+9+4)/3; (9+4+5)/3; lo que resultaría en el vector:
<<>>=
 Z.pmov <- c(7, 8, 8, 8, 7, 6)
@
cuya longitud (6) es menor que la del vector original (8). Entonces, si deseamos comparar gráficamente ambos vectores, lo mejor es que ambos tengan la misma longitud. En este ejemplo se puede hacer agregando \Verb@NA@ al inicio y al final de \Verb@Z.pmov@ para centrar la serie suavizada con respecto a la serie original:
<<>>=
 Z.pmov <- c(NA, Z.pmov, NA)
 Z.pmov
@ 

Para vectores de mayor longitud estos cálculos manuales resultan tediosos, por lo que vamos a 
crear nuestra primera función, a la que denominaremos ``pmov'' y que usaremos para calcular el promedio móvil de las temperaturas de manera más rápida y sencilla:

<<>>=
pmov <- function(x, k) { 
             n  <- length(x)  
             y <- rep(NA, n)
             for (i in k:n)
             y[i-floor(k/2)] <- mean( x[(1+i-k):i] ) 
             y
}
@

En esta función \Verb@x@ es el vector a suavizar y \Verb@k@ es el orden. ``pmov'' calcula primero la longitud del vector, después genera un vector vacío (\Verb@y@) de la misma longitud de \Verb@x@ y por último calcula los promedios correspondientes. Apliquemos esta función a la temperatura diaria promedio con un orden igual a 15 días

<<>>=
 tmean.pmov <- pmov(taire$tavg, 15)
@

Ahora procedamos a graficar la temperatura diaria promedio sobreponiendo los promedios móviles que hemos calculado:

\begin{center}
<<fig=TRUE, echo=TRUE, keep.source=TRUE>>=
  plot(taire$tavg, type = "o", ylab = "temperatura (°C)", xlab = "día", 
       main = "Temp. diaria promedio en La Paz \n (junio 2006 a mayo 2007)", 
       lty = 3, col="grey50", lwd = 1)
 lines(tmean.pmov, lwd = 2, col = "blue")
@
\end{center}

También podemos presentar esta información como anomalías:
<<>>=
 anomalia <- tmean.pmov-mean(tmean.pmov, na.rm=TRUE)
 anomalia[is.na(anomalia)] <- 0
@

Para la figura correspondiente, pero esta vez usando etiquetas adecuadas para los meses en el eje 'x' y dibujando un polígono que es como se suele representar este tipo de información, necesitamos obtener el número de días de cada mes. Primero extraemos los valores únicos de las primeras tres columnas de \Verb@cibmeteo@ con la función \Verb@unique()@ y a continuación contamos los días por mes y por año con ayuda de la función \Verb@aggregate()@

<<>>=
 dias <- unique(cibmeteo[, 1:3])
 ndmes <- aggregate(dias$day, by = list(dias$month, dias$year), length)
 ndmes
@

usaremos el vector \Verb@ndmes$x@ para dibujar un grid vertical y poner las etiquetas en la gráfica:

\begin{center}
<<fig=TRUE, echo=TRUE, keep.source=TRUE>>=
 plot(anomalia, type="n", ylab = "anomalía de temperatura", xlab = "", 
      xaxt = "n" )
	polygon(c(1:364, 364:1), c(anomalia, rep(0, 364)), col="green")
  abline(h=0, v=c(0, cumsum(ndmes$x)), col="black", lty=3)
  axis(1, at=cumsum(ndmes$x)-ndmes$x/2, labels = c("jun","jul","ago",
      "sep","oct","nov","dic","ene","feb","mar","abr","may"))
@
\end{center}


\section{Exportar tablas y figuras}
Si deseamos exportar algunos de nuestros resultados podemos usar el comando:

<<eval=FALSE, keep.source=TRUE>>=
 write.table(taire, file = "temp_aire.txt", quote = FALSE, sep = "\t", 
             dec = ".", row.names = TRUE, col.names = TRUE)
@
 
Las figuras pueden salvarse en diversos formatos a partir del menú \textbf{File/Save As} de la ventana gráfica, o bien dentro de nuestro script podemos especificarlo:

<<eval=FALSE>>=
 	savePlot(filename="Figura_1", type="png")
@ 

En ambos casos, tanto las figuras como las tablas serán guardadas en el directorio de trabajo especificado previamente.

\section{Algunos análisis de ejemplo}

 \subsection{Análisis de regresión lineal}

Para este ejemplo vamos a generar un par de variables ficticias. La variable independiente consistirá en una serie de valores del 1 al 100, y la variable dependiente será calculada usando un valor de 2.5 para la pendiente y de 31 para la ordenada al origen, añadiendo un termino de error aleatorio a la ecuación de la recta:

<<>>=
x <- 1:100 
y <- 2.5*x + 31 + (rnorm(100) * 9)
@

Creemos la gráfica de dispersión  de nuestras variables ficticias: 

<<fig=TRUE, echo=TRUE>>=
  plot(x, y)
@

Y ahora procedamos a efectuar la regresión usando la función \Verb@lm()@, para lo cual debemos especificar el modelo en notación de fórmula: 
\begin{verbatim}
  y ~ x
\end{verbatim}

Esta fórmula es equivalente a: \Verb@Y = aX + b@ dado que por defecto, la función \Verb@lm()@ calcula el intercepto. Si se desea forzar el intercepto a cero, el modelo debe escribirse de la siguiente forma:
\begin{verbatim}
  y ~ x + 0
\end{verbatim}

Apliquemos pues la función \Verb@lm()@ guardando el resultado en un objeto denominado \Verb@xy.lm@:

<<>>=
  xy.lm <- lm(y ~ x)
@

Para ver el resultado de la regresión utilizamos la función \Verb@summary()@:
<<>>=
  summary(xy.lm)
@

Otros detalles del objeto \Verb@xy.lm@ pueden verse con la función \Verb@attributes()@:

<<>>=
 attributes(xy.lm)
@

Para extraer los coeficientes de la regresión: 
<<>>=
 coef(xy.lm)
@


A continuación podemos añadir el modelo ajustado a la figura anterior:

<<eval=FALSE, echo=TRUE>>=
  abline(xy.lm)
@

<<fig=TRUE, echo=FALSE>>=
  plot(x, y)
  abline(xy.lm)
@

Por último, podemos explorar los residuales
<<fig=TRUE, echo=TRUE>>=
  par(mfrow=c(2,2))
  plot(xy.lm)
@ 


<<echo=FALSE>>=
 graphics.off()
@



 \subsection{Estimación no lineal}

Como en el ejemplo anterior generamos dos variables  ficticias \Verb@X@ y \Verb@Y@. En el caso de \Verb@Y@ utilizamos un modelo potencial sin olvidar agregar un término de error aleatorio.

<<>>=
  X <- seq(1, 20, length=100) 
  Y <- 2.5 *( X+runif(100)*3 )^2.5
@    

Creamos la gráfica para explorar visualmente la relación entre las dos variables:

<<fig=TRUE, echo=TRUE>>=  
  plot(X, Y)
@

Ahora usemos la función de estimación no lineal \Verb@nls()@. En este caso, además de especificar el modelo a ajustar (\Verb@Y ~ a*X^b@) debemos  especificar valores iniciales de los parámetros de la función. El algoritmo por defecto es el de Gauss-Newton (ver la ayuda de la función \Verb@nls()@ para mayores detalles).

<<keep.source=TRUE>>=
  modelo.potencial <- nls(Y ~ a * X^b, start = list(a=1, b=1), trace=TRUE, 
                          algorithm="default", model = TRUE)
@

Para ver los parámetros ajustados usamos \Verb@coef()@, y la función \Verb@summary()@ nos muestra resultados adicionales:

<<>>=
  coef(modelo.potencial)
  summary(modelo.potencial)
@

Por último, añadimos este modelo final a la gráfica:
<<echo=TRUE,eval=FALSE>>=
   lines(X, predict(modelo.potencial), col="red", lwd=2)
@

<<fig=TRUE, echo=FALSE>>=
  plot(X, Y)
   lines(X, predict(modelo.potencial), col="blue", lwd=2)
@



La estimación no lineal es sensible a los valores iniciales utilizados, por lo que en ocasiones puede no tener éxito. En esos casos se puede efectuar una estimación previa de los parámetros usando la función \Verb@optim()@. En esta,  se requiere un criterio a minimizar, generalmente la suma de los residuales al cuadrado:

 $$\sum(Y_{obs}-Y_{calc})^2$$ 
y además se deben especificar valores semilla para los parámetros, con la ventaja de que la función de optimización es menos exigente respecto a los valores iniciales utilizados.


\subsection{Análisis de variancia}

Para ilustrar este último caso, utilizaremos un ejemplo de Daniel\footnote{Daniel, W.W., 1993. Bioestadística. Base para el análisis de las ciencias de la salud. 3a ed. Uteha, Noriega Editores. 667 pp.}  (1993, p. 286). En un estudio del efecto de la glucosa sobre la liberación de insulina, se trataron muestras de tejido pancreático de animales de laboratorio con 5 estimulantes distintos. Posteriormente se determinó la cantidad de insulina liberada.

Los datos se encuentran en el archivo ``exaov.txt'' proporcionado

<<eval=FALSE>>=
 exaov <- read.table("exaov.txt" ,header=TRUE, sep=";")
@

<<echo=FALSE>>=
 exaov <- read.table("exaov.txt" ,header=TRUE, sep=";")
@

Una vez importados los datos procedemos a examinar el tamaño de la matriz, los nombres de las variables y las estadísticas descriptivas.

<<>>=
 dim(exaov)
 names(exaov)
 summary(exaov)
@

Nos interesa probar el efecto del estimulante sobre la cantidad de insulina liberada. La función a utilizar es \Verb@aov()@ en la que especificamos los argumentos en notación de fórmula:

<<>>=
 insul.anova <- aov(insulina ~ as.factor(estimulante), data=exaov)
@

Los resultados del análisis  los podemos ver invocando el objeto recién creado y con la función \Verb@summary()@ usada anteriormente:

<<>>=
 insul.anova
 summary(insul.anova)
@




\begin{thebibliography}[Lecturas Recomendadas](\section,0.5cm){99}

\bibitem{cit1}     
     Everitt, B. y Hothorn, T. 2006. A Handbook of Statistical Analyses Using R Chapman \& Hall/CRC, 275 pp.   
 \bibitem{cit2}
     Murrell, P. 2005. R Graphics. Chapman \& Hall/CRC. 301 pp. 
 \bibitem{cit3}
     Paradis, E. 2005. R For Beginners. 72 pp. Disponible en Internet: 
     \url{http://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf}
 \bibitem{cit4}
     R Core Team. 2012. R Language Definition. Versión 2.15.2 (2012-10-26) DRAFT. ISBN 3-900051-13-5. 55 pp. 
 \bibitem{cit5}
     Venables, W. N.y Ripley, B. D. 2002. Modern Applied Statistics with S. 4a Edición. Springer. 495 pp.
 \bibitem{cit6}
      Venables, W. N., D.M. Smith y R Development Core Team. 2009. An Introduction to R. Notes on R: A Programming Environment for Data Analysis and Graphics. Versión 2.9.1 (2009-06-26). ISBN 3-900051-12-7. 94 pp.


 \end{thebibliography}

%\printindex



\end{document}

